<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
	<head>
		<title>Глава 1.Циклы и функции</title>
        <link href="../../css/style.css" rel="stylesheet">
        <script src="../../js/script.js"></script>
		<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
    </head>
    <body onload="preConvert()">
        <div class = "content">
            <h1>Циклы</h1>
            <ul>
                <h2>В этом параграфе</h2>
                <li><a href="#cicle">Циклы</a></li> <br>
                <li><a href="#func">Функции</a></li><br>
                <li><a href="#ques">Вопросы для самоконтроля</a></li><br>
            </ul>
            
            <a name="cicle"></a>
            <strong><p>Цикл while</p></strong>
            
            <p>While - один из самых универсальных циклов в Python, поэтому довольно медленный. Выполняет тело цикла до тех пор, пока условие цикла истинно.

<p>>>>
<p>>>> i = 5
<p>>>> while i < 15:
<p>...     print(i)
<p>...     i = i + 2
<p>...
<p>5
<p>7
<p>9
<p>11
<p>13

            </p>

            
          <strong>  <p>Цикл for</p></strong>

<p>Цикл for уже чуточку сложнее, чуть менее универсальный, но выполняется гораздо быстрее цикла while. Этот цикл проходится по любому итерируемому объекту (например строке или списку), и во время каждого прохода выполняет тело цикла.

<p>>>>
<p>>>> for i in 'hello world':
<p>...     print(i * 2, end='')
<p>...
<p>hheelllloo  wwoorrlldd
                
            </p>
           
            <strong><p>Оператор continue</p></strong>
<p>

<p>Оператор continue начинает следующий проход цикла, минуя оставшееся тело цикла (for или while)

<p>>>>
<p>>>> for i in 'hello world':
<p>...     if i == 'o':
<p>...         continue
<p>...     print(i * 2, end='')
<p>...
<p>hheellll  wwrrlldd

    <strong><p>Оператор break</p></strong>
<p>Оператор break досрочно прерывает цикл.

<p>>>>
<p>>>> for i in 'hello world':
<p>...     if i == 'o':
<p>...         break
<p>...     print(i * 2, end='')
<p>...
<p>hheellll

    <strong><p>Волшебное слово else</p></strong>
    <p>Слово else, примененное в цикле for или while, проверяет, был ли произведен выход из цикла инструкцией break, или же "естественным" образом. Блок инструкций внутри else выполнится только в том случае, если выход из цикла произошел без помощи break.

<p>>>>
<p>>>> for i in 'hello world':
<p>...     if i == 'a':
<p>...         break
<p>... else:
<p>...     print('Буквы a в строке нет')
<p>...
<p>Буквы a в строке нет
    <a name="func"></a>
        <h2>Функции</h2>
   <p>     Именные функции, инструкция def


<p>Функцияв python - объект, принимающий аргументы и возвращающий значение. Обычно функция определяется с помощью инструкции def.

<p>Определим простейшую функцию:
<p>def add(x, y):
<p>    return x + y

<p>Инструкция return говорит, что нужно вернуть значение. В нашем случае функция возвращает сумму x и y.

<p>Теперьмы ее можем вызвать:

<p>>>>
<p>>>> add(1, 10)
<p>11
<p>>>> add('abc', 'def')
<p>'abcdef'

<p>Функция может быть любой сложности и возвращать любые объекты (списки, кортежи, и даже функции!):

<p>>>>
<p>>>> def newfunc(n):
<p>...     def myfunc(x):
<p>...         return x + n
<p>...     return myfunc
<p>...
<p>>>> new = newfunc(100)  # new - это функция
<p>>>> new(200)
<p>300

<p>Функция может и не заканчиваться инструкцией return, при этом функция вернет значение None:

<p>>>>
<p>>>> def func():
<p>...     pass
<p>...
<p>>>> print(func())
<p>None

            <strong><p>Аргументы функции</p></strong>
            <p>Функция может принимать произвольное количество аргументов или не приниматьих вовсе. Также распространены функции с произвольным числом аргументов, функции с позиционными и именованными аргументами, обязательными и необязательными.

<p>>>>
<p>>>> def func(a, b, c=2): # c - необязательный аргумент
<p>...     return a + b + c
<p>...
<p>>>> func(1, 2)  # a = 1, b = 2, c = 2 (по умолчанию)
<p>5
<p>>>> func(1, 2, 3)  # a = 1, b = 2, c = 3
<p>6
<p>>>> func(a=1, b=3)  # a = 1, b = 3, c = 2
<p>6
<p>>>> func(a=3, c=6)  # a = 3, c = 6, b не определен
<p>Traceback (most recent call last):
<p>  File "", line 1, in
<p>    func(a=3, c=6)
<p>TypeError: func() takes at least 2 arguments (2 given)

<p>Функция также может принимать переменное количество позиционных аргументов, тогда перед именем ставится *:

<p>>>>
<p>>>> def func(*args):
<p>...     return args
<p>...
<p>>>> func(1, 2, 3, 'abc')
<p>(1, 2, 3, 'abc')
<p>>>> func()
<p>()
<p>>>> func(1)
<p>(1,)
<p>
Как видно из примера, args - это кортеж извсех переданных аргументов функции, и с переменной можно работать также, как и с кортежем.
<p>
Функция может принимать и произвольное число именованных аргументов, тогда перед именем ставится **:
<p>
>>>
<p>
>>> def func(**kwargs):<p>
...     return kwargs<p>
...<p>
>>> func(a=1, b=2, c=3)<p>
{'a': 1, 'c': 3, 'b': 2}<p>
>>> func()<p>
{}<p>
>>> func(a='python')<p>
{'a': 'python'}<p>

В переменной kwargs у нас хранится словарь, с которым мы, опять-таки, можем делать все, что нам заблагорассудится.
 <strong><p>Анонимные функции, инструкция lambda</p></strong>
 <p>Анонимные функции могут содержать лишь одно выражение, но и выполняются они быстрее. Анонимные функции создаются с помощью инструкции lambda. Кроме этого, их не обязательно присваивать переменной, как делали мы инструкцией def func():
<p>
>>><p>
>>> func = lambda x, y: x + y<p>
>>> func(1, 2)<p>
3<p>
>>> func('a', 'b')<p>
'ab'<p>
>>> (lambda x, y: x + y)(1, 2)<p>
3<p>
>>> (lambda x, y: x + y)('a', 'b')<p>
'ab'<p>

lambda функции, в отличие от обычной, не требуется инструкция return, а востальном, ведет себя точно так же:
<p>
>>><p>
>>> func = lambda *args: args<p>
>>> func(1, 2, 3, 4)<p>
(1, 2, 3, 4)<p>

            <a name="ques"></a>
            <h3>Вопросы для самоконтроля:</h3>
            <ul>
               <li>Какие битовые операции можно совершить над целыми числами?</li>
                <li>Что включает в себя модуль math?</li>
            </ul>
        </div>
	</body>
</html>